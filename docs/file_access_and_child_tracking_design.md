# eBPF LSM を用いたファイルアクセス制御（cgroup ベース・deny-list 方式）

## 背景
mori はサンドボックスツールとして、対象プロセス（および子プロセス）による **ファイルアクセス** を制御する。
本設計では **BPF_LSM_CGROUP** を活用し、対象プロセスを cgroup v2 に配置することで、カーネルが自動的にスコープをフィルタリングする方式を採用する。
これにより PID 管理や cgroup ID の手動比較が不要になり、シンプルかつ堅牢な実装を実現する。

**制御方式**: **Deny-list（拒否リスト）方式** を採用。デフォルトで全てのファイルアクセスを許可し、指定したパスのみ拒否する。

---

## 全体アーキテクチャ
- **スコープ**: 対象 cgroup 配下のすべてのプロセス（親・子・孫を含む）
- **判定**: カーネルが自動的に対象 cgroup 内のプロセスのみ LSM フックを発火（eBPF 内での cgroup ID 比較不要）
- **制御方式**: eBPF 内で拒否リストマップを参照し、リストにあれば拒否、なければ許可（ユーザ空間との往復なし）
- **ログ出力**: aya-log を使用して拒否イベントをユーザ空間にログ出力
- **イベント**:
  - ファイルアクセス制御
    - `file_open` (LSM) : ファイルオープン時の制御
    - `file_permission` (LSM) : 読み書きアクセス時の制御

---

## eBPF 実装仕様

### マップ
- `DENY_PATHS` (deny-list 方式)
  - `HashMap<[u8; 256], u8>`
  - キー: ファイルパス（最大 256 バイト、NUL 終端）
  - 値: アクセスモード（1=READ, 2=WRITE, 3=READ|WRITE）
  - **デフォルト動作**: マップが空の場合、全てのファイルアクセスを許可

### フックプログラム
#### file_open
- **attach タイプ**: `BPF_LSM_CGROUP`
- **処理フロー**:
  1. ファイルパスを `bpf_d_path()` で取得（最大 256 バイト）
  2. パスが 256 バイトを超える場合は `-ENAMETOOLONG` で拒否
  3. `DENY_PATHS` マップでパスを検索
  4. **見つかれば `-EPERM` (拒否)、見つからなければ `0` (許可)**
  5. 拒否時は `aya_log_ebpf::warn!()` でログ出力

#### file_permission
- **attach タイプ**: `BPF_LSM_CGROUP`
- **処理フロー**:
  1. ファイルパスを `bpf_d_path()` で取得
  2. `mask` フィールドで読み書きを判定（`MAY_READ` / `MAY_WRITE`）
  3. `DENY_PATHS` マップでパスとアクセスモードを確認
  4. **拒否リストにあれば `-EPERM`、そうでなければ `0` (許可)**
  5. 拒否時はログ出力

---

## ユーザ空間実装仕様

### 初期化手順
1. CLI フラグ (`--deny-file`, `--deny-file-read`, `--deny-file-write`) または設定ファイルからファイルポリシーを読み込む
2. ファイルパスを絶対パス化・正規化し、`FilePolicy` を構築
3. cgroup を作成（`/sys/fs/cgroup/mori-{pid}`）
4. eBPF プログラム（file_open, file_permission）をロード
5. **拒否ファイルパスとアクセスモードを `DENY_PATHS` マップに挿入**
6. LSM プログラムを `BPF_LSM_CGROUP` モードで attach
7. **親プロセス（mori 自身）を cgroup に移動**
8. 子プロセスを spawn（自動的に cgroup を継承）
9. `aya_log::EbpfLogger` を初期化してログ受信
10. 子プロセスの終了を待機

### 子プロセスの cgroup 継承
- cgroup v2 では、子プロセスは作成時に自動的に親の cgroup を継承
- mori 自身を先に cgroup に移動してから子プロセスを spawn することで、確実に制御下に置く
- 孫プロセス以降も自動的に同じ cgroup に所属

---

## 制御フロー図

```
+-------------------+
| mori cgroup       |
|  (mori-{pid})     |
+---------+---------+
          |
          v
   [mori + 子プロセス群]
          |
          v
   LSM フック (file_open/file_permission)
   ※カーネルが cgroup でフィルタリング
          |
          v
   DENY_PATHS マップ検索（deny-list 方式）
          |
   +------+------+
   |             |
  HIT          MISS
   |             |
return -EPERM  return 0
(拒否 + ログ)  (許可)
   |
   v
mori (EbpfLogger)
   |
   +---------+----------+
   | stderr にログ出力  |
   +-------------------+
```

---

## 運用要件
- Linux kernel: v5.10+（BPF LSM と cgroup v2 が有効）
- 権限: root または CAP_BPF + CAP_SYS_ADMIN
- ファイルパス取得: `bpf_d_path()` から最大 256 バイト
- パスが 256 バイトを超える場合は `-ENAMETOOLONG` でエラー
- cgroup 管理: mori が自動的に専用 cgroup を作成・管理

---

## メリット
- **Deny-list 方式**：デフォルトで全て許可、特定パスのみ拒否でセキュアかつ柔軟
- **BPF_LSM_CGROUP により cgroup ID 管理不要**：カーネルが自動フィルタリング
- **子プロセス追跡を cgroup に委任**：PID 管理不要、自動継承
- **eBPF 内で制御が完結**：ユーザ空間との往復なし、高速
- **RingBuf 不要**：ログは aya-log で出力、構造体共有不要
- **シンプルで堅牢**：実装が簡潔、運用負担が少ない

---

## 制限事項
- ファイルパスは最大 256 バイト（それ以上は拒否）
- mori 自身も cgroup に所属するため、mori のファイルアクセスも制御対象
  - 必要なライブラリや設定ファイルは許可リストに追加が必要な場合あり
- シンボリックリンクの解決は `bpf_d_path()` の挙動に依存

---

## まとめ
本設計は、`BPF_LSM_CGROUP` による **deny-list 方式**のファイルアクセス制御を実現し、**cgroup 単位のスコープ管理**で子プロセスを含めた制御を可能にする。
デフォルトで全て許可し、指定したパスのみ拒否する方式により、柔軟かつセキュアな制御を実現する。
RingBuf やプロセス監視イベントを使わず、eBPF 内で制御が完結するシンプルな設計により、安全かつ効率的なファイルアクセス制御基盤を実装できる。
